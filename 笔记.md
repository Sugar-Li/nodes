# ES6语法

## 1. let和const

### 1.1 let命令

+ 声明变量，但是作用域只存在于当前代码块，区别于var作用于全局变量

  + ```javascript
     // let 和 var 的区别
        // var a=[]
        // for (var i=0; i<10;i++){
        //     a[i]=function () {
        //         console.log(i)
        //     }
        // }
        // a[6]()
     	//10
       
        var a=[]
        for (let i=0; i<10;i++){
            a[i]=function () {
                console.log(i)
            }
        }
        a[6]()
     	//6
     ```
    ```
  
  + 因为var声明的变量是全局变量，所以在整个过程只有一个唯一的i，当循环结束时，i=10，所以最后调用函数打印i的时候打印出来的是10
  
  + 而let声明值在当前循环适用，所以每一次循环打印出来的i都不一样，都只能作用于自身循环的作用域，因此能得到我们想要的答案 6
    ```

+ 不存在变量提升

  + 使用var声明变量，变量提升即没有声明变量，但是在脚本运行时，已经存在变量只是没有值

  + 使用let时，不会出现这种情况，会直接报错

  + ```javascript
      console.log(foo)//undefined
        var foo=2
       console.log(foo2)//ReferenceError
        let foo2=2//
      ```
    ```
  
    ```

+ 暂时性死区

  + 在块级作用域中，如果存在let，const，则变量就会收到其影响，使用的变量必须声明之后才能调用，否则就会报错
  + 目的是：防止在变量声明前就使用当前变量

+ 不允许重复声明

  + let不允许在相同作用于内，重复声明同一个变量



### 1.2 块级作用域

ES5只有全局作用域和函数作用域，ES6新增块级作用域

+ 为什么需要块级作用域？

  + 内层变量覆盖外层变量

    + ```javascript
       var msg=new Date()
         
          function f() {
              console.log(msg)
              if (false) {
                  var msg='hello world'
              }
          }
          f()//undefined
       ```
      ```
    
    + 因为`msg` 是全局变量，所以在函数中内层的`msg`是属于函数作用域的，因此一开始打印`msg`就是undefined
    
    + 如果换成`let`声明变量,那么`if`包裹的块级作用域不会影响外层的变量，则打印的`msg`会找到最外层的`msg`并打印出来
      ```

  + 计数的循环变量泄露成全局变量

+ ES6块级作用域





### 1.3 const 命令

+ 概念：const 声明一个只读的常量，一旦声明，就不能改变

+ 本质：const保证的是指向的内存地址保持不变，当地址保存的数据是数字，字符串，布尔值等，等同于常量；但是如果指向的是一个对象，那么指向这个对象的地址是不变的，但是这个对象是可变，当这个对象发生改变时，const定义的变量也会发生改变。
  + ```javascript
    const foo={}
        console.log(foo.prop)//undefined
    
        foo.prop=123
        console.log(foo.prop)//123
    ```

+ ES6有6中声明方式

  + var function
  + const let
  + import class



### 1.4 顶层对象属性

在ES6之前，全局变量var 和 function 声明的变量和顶层对象的属性赋值是挂钩的，后面新增的let，const，class等全局变量则和顶层对象属性脱离



## 



## 2. 变量的解构赋值

### 2.1数组的解构赋值

ES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这被称为解构



### 2.2对象的解构赋值

数组是按照次序排列的，变量由它的位置决定；而对象的属性没有次序，变量必须与属性同名



### 2.3字符串的解构赋值

+ 可以用数组将字符串的每个字符解构出来
+ 可以用 `{length:len}`将字符串的长度解构出来



### 2.4数值和布尔值的解构赋值



### 2.5函数参数的解构赋值

+ 为函数参数指定默认值

  + ```javascript
    function move({x,y}={x:1,y:3}) {
            return[x,y]
        }
        console.log(move({x:11,y:33}))//[11,33]
        console.log(move({x:11}))//[11,undefined]
        console.log(move({}))//[undefined,undefined]
        console.log(move())//[1,3]
    ```

+ 为函数参数变量指定默认值

  + ```javascript
     function move({x=1,y=3}={}) {
            return[x,y]
        }
        console.log(move({x:11,y:33}))//[11,33]
        console.log(move({x:11}))//[11,3]
        console.log(move({}))//[1,3]
        console.log(move())//[1,3]
     ```
    ```
  
    ```



## 3. 字符串的扩展

### 3.1 includes(),startsWith(),endsWith()

+ 返回值都是布尔值，判断字符串相应的关系是否存在
  + includes()--包含
  + startsWith()--以某字符串开始
  + endsWith()--以某字符串结尾
+ 第二参数
  +  搜索开始的位置
    + endsWith()不同，它的第二个参数表示只真对前n个数字

### 3.2 repeat()

+ 将原字符串重复n次
  + 如果是小数，则向下取整
  + 如果是-1,0之间，取0次



### 3.3 padStart(),padEnd()

+ 字符串补全长度，
  + 第一个参数是长度，第二参数是补全的字符串
  + 如果元字符串大于或等于第一个参数的长度，则返回原字符串
  + 如果第二个参数的字符串过长，到了相应长度，多出来的会被砍掉
  + 如果省略第二个参数，默认使用空格补全
+ 主要用途：
  + 数值补全指定位数
  + 字符串格式（日期）



### 3.4 模板字符串（拼串）

+ ${变量}+``引用整一个字符串
+ 可以嵌套，可以加入函数，用反引号会保留当前样式





## 4. 正则的扩展

### 4.1 RegExp构造函数



### 4.2 字符串的正则方法



## 5.数值的扩展



## 6.函数的扩展

### 6.1函数参数的默认值

+ 参数是默认声明的，不能再用const和let再次声明
  + 使用参数默认值时不能出现同名参数
  + 参数默认值是惰性求值
    + 惰性求值：函数在调用时才进行参数求值计算，而并非是参数定义后立刻求值
+ 与解构赋值默认值结合使用
+ 参数默认值的位置
  + 一般定义默认参数的值放在尾部，因为可以忽略该参数，但是一旦不是放在尾部，调用的时候不能忽略该参数而直接给后面的参数赋值
  + 传入undefined则获取默认值，但是传入null则直接导出null
+ 函数的`length`属性
  + 返回没有指定默认值的参数个数，也就是说设置参数默认值会使length属性失真
  + `length` 属性的含义是 函数预期传入的参数个数
  + 如果默认值参数不是尾参数，该参数后面的参数也不包含在length里，值计算拥有默认值参数前的参数
+ 作用域
  + 设置参数默认值，函数进行声明初始化时，参数会形成一个单独的作用域